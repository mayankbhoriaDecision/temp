#!/bin/bash

# This script is designed to automate the process of deploying Docker images to a GKE cluster.
# It performs the following steps:
# 1. Enables necessary Google Cloud APIs.
# 2. Connects to the user's Google Cloud account.
# 3. Creates an Artifact Repository in Google Cloud.
# 4. Configures Docker to authenticate with the Artifact Registry.
# 5. Retrieves the credentials for the GKE cluster.
# 6. Registers the GKE cluster with Anthos.
# 7. Enables Anthos Service Mesh on the project's Fleet.
# 8. Provisions managed Anthos Service Mesh on the cluster using the Fleet API.
# 9. Enables Cloud Run for Anthos on the cluster.
# 10. Enables Ingress for the cluster.
# 11. Loops through each namespace directory in a specified parent directory.
# 12. For each namespace, it loops through each service directory.
# 13. If a .yaml file is found in the service directory, it extracts the app name and image URL from the file.
# 14. It then pulls the Docker image, tags it, and pushes it to the Artifact Registry.
# 15. If a Kubernetes deployment with the same name already exists, it updates the existing deployment with the new Docker image.
# 16. If a deployment with the same name does not exist, it creates a new deployment.
# 17. Finally, it validates the deployed function by retrieving the deployment details from Kubernetes.


# Set the parent directory
PARENT_DIR="/home/mbhoria1/"


# Prompt for user input
read -p "Enter the cluster name: " CLUSTER_NAME
read -p "Enter the repo name: " ARTIFACT_REPO

# Set additional variables
PROJECT_ID="jxlkoxwl-0i3y-2tps-pksr-vhved4"
REGION="us-central1"
ZONE="us-central1-c"


# Function to check the status of the last command and exit if it failed
function check_status {
    if [ $? -ne 0 ]; then
        echo "Error: Previous command failed."
        exit 1
    fi
}

# Enable necessary APIs
echo "Enabling necessary APIs..."
gcloud services enable \
cloudresourcemanager.googleapis.com \
container.googleapis.com \
artifactregistry.googleapis.com \
containerregistry.googleapis.com \
containerscanning.googleapis.com \
run.googleapis.com
check_status
echo "APIs enabled."

# Connect gcloud account
echo "Connecting gcloud account..."
gcloud auth login
check_status
echo "gcloud account connected."

# Create artifact repo in gcloud
echo "Creating artifact repo in gcloud..."
gcloud artifacts repositories create $ARTIFACT_REPO --project=$PROJECT_ID --location=$REGION --repository-format=docker
#check_status
echo "Artifact repo created."

# Configure docker authentication to artifact registry
echo "Configuring Docker authentication..."
gcloud auth configure-docker $REGION-docker.pkg.dev
check_status
echo "Docker authentication configured."

# Get credentials for the GKE cluster
echo "Getting credentials for the GKE cluster..."
gcloud container clusters get-credentials $CLUSTER_NAME --region $REGION --project $PROJECT_ID
check_status
echo "Credentials retrieved."

# Registering with Anthos
echo "Registering with Anthos..."

gcloud container fleet memberships register $CLUSTER_NAME \
--gke-cluster=$REGION/$CLUSTER_NAME \
--enable-workload-identity \
--project $PROJECT_ID
check_status

echo "Registration complete."

# Enable Anthos Service Mesh on your project's Fleet
echo "Enabling Anthos Service Mesh..."
gcloud container fleet mesh enable --project $PROJECT_ID
#check_status
echo "Anthos Service Mesh enabled."

# Provision managed Anthos Service Mesh on the cluster using the Fleet API
echo "Provisioning managed Anthos Service Mesh on the cluster..."
gcloud container fleet mesh update \
  --management automatic \
  --memberships $CLUSTER_NAME \
  --project $PROJECT_ID
check_status
echo "Provisioning complete."

# Enable cloud run anthos  
echo "Enabling Cloud Run for Anthos..."
gcloud container fleet cloudrun enable --project $PROJECT_ID
gcloud container fleet cloudrun apply --gke-cluster=$REGION/$CLUSTER_NAME
check_status
echo "Cloud Run for Anthos enabled."

# Enable ingress
echo "Enabling ingress..."
gcloud container fleet ingress enable --config-membership=https://gkehub.googleapis.com/v1/projects/$PROJECT_ID/locations/$REGION/memberships/$CLUSTER_NAME
check_status
echo "Ingress enabled."

echo "Looking for Images in Namespace Folders"

# Loop through each namespace directory in the parent directory
for NAMESPACE_DIR in $PARENT_DIR/CTC8/*; do
    # Loop through each kn-svc directory in the namespace directory
    for SVC_DIR in $NAMESPACE_DIR/*; do
        # Check if there are any .yaml files in the directory
        if ls $SVC_DIR/*.yaml 1> /dev/null 2>&1; then
            # Extract the app name from the directory path
            arrIN=(${SVC_DIR//// })
            APP_NAME="${arrIN[1]}"

            echo "Creating Namespace"

            FOLDER_PATH=$NAMESPACE_DIR

            NAMESPACE_final=$(basename $FOLDER_PATH)

            NAMESPACE_final=$(echo $NAMESPACE_final | tr '[:upper:]' '[:lower:]')

            echo $NAMESPACE_final

            kubectl create namespace $NAMESPACE_final

            # Extract the image URL from the yaml file
           # IMG_STR=$(grep -iR image: $SVC_DIR)
           # arrIM=(${IMG_STR//image: / })
            #IMAGE_URL=${arrIM[1]}


            IMAGE_URL=$(grep -iR 'image:' $SVC_DIR | awk '{print $4}')
 
            # Pull the Docker image
            echo "Pulling Docker image $IMAGE_URL..."
            docker pull $IMAGE_URL
            check_status
            echo "Docker image pulled."

            # Tag the Docker image
            echo "Tagging Docker image..."
            docker tag $IMAGE_URL $REGION-docker.pkg.dev/$PROJECT_ID/$ARTIFACT_REPO/$APP_NAME
            check_status
            echo "Docker image tagged."

            # Push the Docker image to the gcloud artifact repo
            echo "Pushing Docker image to gcloud artifact repo..."
            docker push $REGION-docker.pkg.dev/$PROJECT_ID/$ARTIFACT_REPO/$APP_NAME
            check_status
            echo "Docker image pushed."

            # Check if the deployment already exists
            if kubectl get deployments $APP_NAME --namespace=$(basename $NAMESPACE_final) > /dev/null 2>&1; then
                # Update the existing deployment
                echo "Updating existing Kubernetes deployment..."
                kubectl set image deployment/$APP_NAME $APP_NAME=$REGION-docker.pkg.dev/$PROJECT_ID/$ARTIFACT_REPO/$APP_NAME --namespace=$(basename $NAMESPACE_final)
                check_status
                echo "Deployment updated."

                kubectl expose deployment $APP_NAME --type=LoadBalancer --name=$APP_NAME-svc --port=80 --target-port=8080 --namespace=$(basename $NAMESPACE_final)

            else
                # Create a new Kubernetes deployment
                echo "Creating new Kubernetes deployment..."
                kubectl create deployment $APP_NAME --image=$REGION-docker.pkg.dev/$PROJECT_ID/$ARTIFACT_REPO/$APP_NAME --namespace=$(basename $NAMESPACE_final)
                check_status
                echo "Deployment created."

                #Expose Deployment

            

                kubectl expose deployment $APP_NAME --type=LoadBalancer --name=$APP_NAME-svc --port=80 --target-port=8080 --namespace=$(basename $NAMESPACE_final)

            fi

            # Validate the deployed function
            echo "Validating the deployed function..."
            kubectl get deployments $APP_NAME --namespace=$(basename $NAMESPACE_final)
            check_status
            echo "Validation in progress."

            # Verify pods in istio-system
            echo "Verifying pods in istio-system..."
            kubectl get pods --namespace=$(basename $NAMESPACE_final)
            check_status
            echo "Verification complete."

        else
            echo "No .yaml files found in $SVC_DIR. Skipping..."
        fi
    done
done
